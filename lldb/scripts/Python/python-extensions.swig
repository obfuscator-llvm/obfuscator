
%extend lldb::SBAddress {
        %nothreadallow;
        PyObject *lldb::SBAddress::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBBlock {
        %nothreadallow;
        PyObject *lldb::SBBlock::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBBreakpoint {
        %nothreadallow;
        PyObject *lldb::SBBreakpoint::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}

}
%extend lldb::SBBreakpointLocation {
        %nothreadallow;
        PyObject *lldb::SBBreakpointLocation::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelFull);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBBreakpointName {
        %nothreadallow;
        PyObject *lldb::SBBreakpointName::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBBroadcaster {
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}

%extend lldb::SBCommandReturnObject {
        %nothreadallow;
        PyObject *lldb::SBCommandReturnObject::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
        /* the write() and flush() calls are not part of the SB API proper, and are solely for Python usage
        they are meant to make an SBCommandReturnObject into a file-like object so that instructions of the sort
        print >>sb_command_return_object, "something"
        will work correctly */

        void lldb::SBCommandReturnObject::write (const char* str)
        {
            if (str)
                $self->Printf("%s",str);
        }
        void lldb::SBCommandReturnObject::flush ()
        {}
}
%extend lldb::SBCompileUnit {
        %nothreadallow;
        PyObject *lldb::SBCompileUnit::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBData {
        %nothreadallow;
        PyObject *lldb::SBData::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBDebugger {
        %nothreadallow;
        PyObject *lldb::SBDebugger::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBDeclaration {
        %nothreadallow;
        PyObject *lldb::SBDeclaration::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}

}
%extend lldb::SBError {
        %nothreadallow;
        PyObject *lldb::SBError::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBFileSpec {
        %nothreadallow;
        PyObject *lldb::SBFileSpec::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBFrame {
        %nothreadallow;
        PyObject *lldb::SBFrame::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBFunction {
        %nothreadallow;
        PyObject *lldb::SBFunction::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}

}
%extend lldb::SBInstruction {
        %nothreadallow;
        PyObject *lldb::SBInstruction::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBInstructionList {
        %nothreadallow;
        PyObject *lldb::SBInstructionList::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBLineEntry {
        %nothreadallow;
        PyObject *lldb::SBLineEntry::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}

%extend lldb::SBMemoryRegionInfo {
        %nothreadallow;
        PyObject *lldb::SBMemoryRegionInfo::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBModule {
        %nothreadallow;
        PyObject *lldb::SBModule::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}

%extend lldb::SBModuleSpec {
        %nothreadallow;
        PyObject *lldb::SBModuleSpec::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBModuleSpecList {
        %nothreadallow;
        PyObject *lldb::SBModuleSpecList::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBProcess {
        %nothreadallow;
        PyObject *lldb::SBProcess::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBSection {
        %nothreadallow;
        PyObject *lldb::SBSection::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
        
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBStream {
        /* the write() and flush() calls are not part of the SB API proper, and are solely for Python usage
        they are meant to make an SBStream into a file-like object so that instructions of the sort
        print >>sb_stream, "something"
        will work correctly */

        void lldb::SBStream::write (const char* str)
        {
            if (str)
                $self->Printf("%s",str);
        }
        void lldb::SBStream::flush ()
        {}
}
%extend lldb::SBSymbol {
        %nothreadallow;
        PyObject *lldb::SBSymbol::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBSymbolContext {
        %nothreadallow;
        PyObject *lldb::SBSymbolContext::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBSymbolContextList {
        %nothreadallow;
        PyObject *lldb::SBSymbolContextList::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}

%extend lldb::SBTarget {
        %nothreadallow;
        PyObject *lldb::SBTarget::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;

    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}

%extend lldb::SBType {
        %nothreadallow;
        PyObject *lldb::SBType::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeCategory {
        %nothreadallow;
        PyObject *lldb::SBTypeCategory::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeFilter {
        %nothreadallow;
        PyObject *lldb::SBTypeFilter::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBTypeFormat {
        %nothreadallow;
        PyObject *lldb::SBTypeFormat::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeMember {
        %nothreadallow;
        PyObject *lldb::SBTypeMember::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeMemberFunction {
        %nothreadallow;
        PyObject *lldb::SBTypeMemberFunction::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeEnumMember {
        %nothreadallow;
        PyObject *lldb::SBTypeEnumMember::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBTypeNameSpecifier {
        %nothreadallow;
        PyObject *lldb::SBTypeNameSpecifier::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBTypeSummary {
        %nothreadallow;
        PyObject *lldb::SBTypeSummary::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBTypeSynthetic {
        %nothreadallow;
        PyObject *lldb::SBTypeSynthetic::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelBrief);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBThread {
        %nothreadallow;
        PyObject *lldb::SBThread::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
    %pythoncode %{ 
        def __eq__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return False 
            
            return getattr(_lldb,self.__class__.__name__+"___eq__")(self, rhs)
            
        def __ne__(self, rhs):
            if not isinstance(rhs, type(self)): 
                return True 
            
            return getattr(_lldb,self.__class__.__name__+"___ne__")(self, rhs)
    %}
}
%extend lldb::SBValue {
        %nothreadallow;
        PyObject *lldb::SBValue::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBValueList {
        %nothreadallow;
        PyObject *lldb::SBValueList::__str__ (){
                lldb::SBStream description;
                const size_t n = $self->GetSize();
                if (n)
                {
                    for (size_t i=0; i<n; ++i)
                        $self->GetValueAtIndex(i).GetDescription(description);
                }
                else
                {
                    description.Printf("<empty> lldb.SBValueList()");
                }
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}
%extend lldb::SBWatchpoint {
        %nothreadallow;
        PyObject *lldb::SBWatchpoint::__str__ (){
                lldb::SBStream description;
                $self->GetDescription (description, lldb::eDescriptionLevelVerbose);
                const char *desc = description.GetData();
                size_t desc_len = description.GetSize();
                if (desc_len > 0 && (desc[desc_len-1] == '\n' || desc[desc_len-1] == '\r'))
                    --desc_len;
                if (desc_len > 0)
                    return lldb_private::PythonString(llvm::StringRef(desc, desc_len)).release();
                else
                    return lldb_private::PythonString("").release();
        }
        %clearnothreadallow;
}


// %extend lldb::SBDebugger {
//         // FIXME: We can't get the callback and baton
//         PyObject *lldb::SBDebugger (){
//             // Only call Py_XDECREF if we have a Python object (or NULL)
//             if (LLDBSwigPythonCallPythonLogOutputCallback == $self->GetLogOutPutCallback())
//                 Py_XDECREF($self->GetCallbackBaton());
//         }
// }

%pythoncode %{

def command(command_name=None, doc=None):
    import lldb
    """A decorator function that registers an LLDB command line
        command that is bound to the function it is attached to."""
    def callable(function):
        """Registers an lldb command for the decorated function."""
        command = "command script add -f %s.%s %s" % (function.__module__, function.__name__, command_name or function.__name__)
        lldb.debugger.HandleCommand(command)
        if doc:
            function.__doc__ = doc
        return function

    return callable

class declaration(object):
    '''A class that represents a source declaration location with file, line and column.'''
    def __init__(self, file, line, col):
        self.file = file
        self.line = line
        self.col = col

class value_iter(object):
    def __iter__(self):
        return self
    
    def next(self):
        if self.index >= self.length:
            raise StopIteration()
        child_sbvalue = self.sbvalue.GetChildAtIndex(self.index)
        self.index += 1
        return value(child_sbvalue)
        
    def __init__(self,value):
        self.index = 0
        self.sbvalue = value
        if type(self.sbvalue) is value:
            self.sbvalue = self.sbvalue.sbvalue
        self.length = self.sbvalue.GetNumChildren()

class value(object):
    '''A class designed to wrap lldb.SBValue() objects so the resulting object
    can be used as a variable would be in code. So if you have a Point structure
    variable in your code in the current frame named "pt", you can initialize an instance
    of this class with it:
    
    pt = lldb.value(lldb.frame.FindVariable("pt"))
    print pt
    print pt.x
    print pt.y

    pt = lldb.value(lldb.frame.FindVariable("rectangle_array"))
    print rectangle_array[12]
    print rectangle_array[5].origin.x'''
    def __init__(self, sbvalue):
        self.sbvalue = sbvalue

    def __nonzero__(self):
        return self.sbvalue.__nonzero__()

    def __str__(self):
        return self.sbvalue.__str__()

    def __getitem__(self, key):
        # Allow array access if this value has children...
        if type(key) is value:
            key = int(key)
        if type(key) is int:
            child_sbvalue = (self.sbvalue.GetValueForExpressionPath("[%i]" % key))
            if child_sbvalue and child_sbvalue.IsValid():
                return value(child_sbvalue)
            raise IndexError("Index '%d' is out of range" % key)
        raise TypeError("No array item of type %s" % str(type(key)))

    def __iter__(self):
        return value_iter(self.sbvalue)

    def __getattr__(self, name):
        child_sbvalue = self.sbvalue.GetChildMemberWithName (name)
        if child_sbvalue and child_sbvalue.IsValid():
            return value(child_sbvalue)
        raise AttributeError("Attribute '%s' is not defined" % name)

    def __add__(self, other):
        return int(self) + int(other)
        
    def __sub__(self, other):
        return int(self) - int(other)
        
    def __mul__(self, other):
        return int(self) * int(other)
        
    def __floordiv__(self, other):
        return int(self) // int(other)
        
    def __mod__(self, other):
        return int(self) % int(other)
        
    def __divmod__(self, other):
        return int(self) % int(other)
        
    def __pow__(self, other):
        return int(self) ** int(other)
        
    def __lshift__(self, other):
        return int(self) << int(other)
        
    def __rshift__(self, other):
        return int(self) >> int(other)
        
    def __and__(self, other):
        return int(self) & int(other)
        
    def __xor__(self, other):
        return int(self) ^ int(other)
        
    def __or__(self, other):
        return int(self) | int(other)
        
    def __div__(self, other):
        return int(self) / int(other)
        
    def __truediv__(self, other):
        return int(self) / int(other)
        
    def __iadd__(self, other):
        result = self.__add__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __isub__(self, other):
        result = self.__sub__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __imul__(self, other):
        result = self.__mul__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __idiv__(self, other):
        result = self.__div__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __itruediv__(self, other):
        result = self.__truediv__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ifloordiv__(self, other):
        result =  self.__floordiv__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __imod__(self, other):
        result =  self.__and__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ipow__(self, other):
        result = self.__pow__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ipow__(self, other, modulo):
        result = self.__pow__(self, other, modulo)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ilshift__(self, other):
        result = self.__lshift__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __irshift__(self, other):
        result =  self.__rshift__(other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __iand__(self, other):
        result =  self.__and__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ixor__(self, other):
        result =  self.__xor__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __ior__(self, other):
        result =  self.__ior__(self, other)
        self.sbvalue.SetValueFromCString (str(result))
        return result
        
    def __neg__(self):
        return -int(self)
        
    def __pos__(self):
        return +int(self)
        
    def __abs__(self):
        return abs(int(self))
        
    def __invert__(self):
        return ~int(self)
        
    def __complex__(self):
        return complex (int(self))
        
    def __int__(self):
        is_num,is_sign = is_numeric_type(self.sbvalue.GetType().GetCanonicalType().GetBasicType())
        if is_num and not is_sign: return self.sbvalue.GetValueAsUnsigned()
        return self.sbvalue.GetValueAsSigned()

    def __long__(self):
        return self.__int__()

    def __float__(self):
        return float (self.sbvalue.GetValueAsSigned())
        
    def __oct__(self):
        return '0%o' % self.sbvalue.GetValueAsUnsigned()
        
    def __hex__(self):
        return '0x%x' % self.sbvalue.GetValueAsUnsigned()

    def __len__(self):
        return self.sbvalue.GetNumChildren()

    def __eq__(self, other):
        if type(other) is int:
                return int(self) == other
        elif type(other) is str:
                return str(self) == other
        elif type(other) is value:
                self_err = SBError()
                other_err = SBError()
                self_val = self.sbvalue.GetValueAsUnsigned(self_err)
                if self_err.fail:
                        raise ValueError("unable to extract value of self")
                other_val = other.sbvalue.GetValueAsUnsigned(other_err)
                if other_err.fail:
                        raise ValueError("unable to extract value of other")
                return self_val == other_val
        raise TypeError("Unknown type %s, No equality operation defined." % str(type(other)))

    def __ne__(self, other):
        return not self.__eq__(other)
%}

%pythoncode %{

class SBSyntheticValueProvider(object):
    def __init__(self,valobj):
        pass

    def num_children(self):
        return 0

    def get_child_index(self,name):
        return None

    def get_child_at_index(self,idx):
        return None

    def update(self):
        pass

    def has_children(self):
        return False


%}

%pythoncode %{

# given an lldb.SBBasicType it returns a tuple
# (is_numeric, is_signed)
# the value of is_signed is undefined if is_numeric == false
def is_numeric_type(basic_type):
    if basic_type == eBasicTypeInvalid: return (False,False)
    if basic_type == eBasicTypeVoid: return (False,False)
    if basic_type == eBasicTypeChar: return (True,False)
    if basic_type == eBasicTypeSignedChar: return (True,True)
    if basic_type == eBasicTypeUnsignedChar: return (True,False)
    if basic_type == eBasicTypeWChar: return (True,False)
    if basic_type == eBasicTypeSignedWChar: return (True,True)
    if basic_type == eBasicTypeUnsignedWChar: return (True,False)
    if basic_type == eBasicTypeChar16: return (True,False)
    if basic_type == eBasicTypeChar32: return (True,False)
    if basic_type == eBasicTypeShort: return (True,True)
    if basic_type == eBasicTypeUnsignedShort: return (True,False)
    if basic_type == eBasicTypeInt: return (True,True)
    if basic_type == eBasicTypeUnsignedInt: return (True,False)
    if basic_type == eBasicTypeLong: return (True,True)
    if basic_type == eBasicTypeUnsignedLong: return (True,False)
    if basic_type == eBasicTypeLongLong: return (True,True)
    if basic_type == eBasicTypeUnsignedLongLong: return (True,False)
    if basic_type == eBasicTypeInt128: return (True,True)
    if basic_type == eBasicTypeUnsignedInt128: return (True,False)
    if basic_type == eBasicTypeBool: return (False,False)
    if basic_type == eBasicTypeHalf: return (True,True)
    if basic_type == eBasicTypeFloat: return (True,True)
    if basic_type == eBasicTypeDouble: return (True,True)
    if basic_type == eBasicTypeLongDouble: return (True,True)
    if basic_type == eBasicTypeFloatComplex: return (True,True)
    if basic_type == eBasicTypeDoubleComplex: return (True,True)
    if basic_type == eBasicTypeLongDoubleComplex: return (True,True)
    if basic_type == eBasicTypeObjCID: return (False,False)
    if basic_type == eBasicTypeObjCClass: return (False,False)
    if basic_type == eBasicTypeObjCSel: return (False,False)
    if basic_type == eBasicTypeNullPtr: return (False,False)
    #if basic_type == eBasicTypeOther:
    return (False,False)

%}
